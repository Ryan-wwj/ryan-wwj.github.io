<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计网-体系（二）</title>
    <link href="/%E8%AE%A1%E7%BD%91-%E4%BD%93%E7%B3%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/%E8%AE%A1%E7%BD%91-%E4%BD%93%E7%B3%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="计网-体系（二）"><a href="#计网-体系（二）" class="headerlink" title="计网-体系（二）"></a>计网-体系（二）</h1><blockquote><p>越学越自信是怎么回事？</p><p>别想，狂做。</p><p>不是从头开始学茴的几种写法，而是搭个雏形框架，然后精雕细琢，逐步深化认识。</p></blockquote><h2 id="从输入网址到页面显示，期间发生了什么"><a href="#从输入网址到页面显示，期间发生了什么" class="headerlink" title="从输入网址到页面显示，期间发生了什么"></a>从输入网址到页面显示，期间发生了什么</h2><p>这是一道面试题。接下来就通过这个问题构建网络拓扑模型。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>浏览器第一步是解析URL，也就是读懂URL。</p><p>URL是统一资源定位符，分为三部分，访问数据协议、Web服务器、数据源路径名。</p><p>使用HTTP协议发起请求，请求报文包括<strong>请求方法、资源路径、HTTP协议版本、信息头、信息体</strong>。Get请求方法没有信息体。返回的响应报文包括协议版本、<strong>状态码</strong>、短语、信息头、信息体。</p><p>应用的数据包格式已经完成。</p><blockquote><p>HTTP和HTTPS有什么区别？</p><p>请求方法Get和Post的区别？</p><p>说下HTTP响应的状态码？</p></blockquote><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>前面提到的Web服务器，一般情况下都是<code>www.xxxx.com</code>之类的域名地址，而不是<code>198.xxx.xxx.10/24</code>之类的 IP地址。所以，<strong>DNS服务器就存放两者之间的映射关系</strong>。</p><p>域名存在层级关系，使用句点代表不同层级的界限，<strong>越往右，层级越高</strong>（参考美国地址的写法）。实际上域名地址的最右侧还有个<code>.</code>的根域名，所以域名层级关系是一个<strong>树结构</strong>，根域名-顶级域名-权威域名。</p><p>指路不带路，客户端向本地DNS服务器请求找到地址对应的IP，如果本地DNS没有缓存，那么就从根域名-顶级域名-权威域名，这样一路问下来知道得到 IP。</p><p>注意并不是每次DNS寻找IP都需要经过这么多步骤，可以靠缓存，DNS解析依次会查找（有顺序的）：</p><ol><li>本地浏览器的缓存</li><li>操作系统的缓存</li><li>hosts文件查看</li><li>本地DNS服务器（最后）</li></ol><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>应用程序调用socket库，委托协议栈工作。</p><p>协议栈上半部分分为TCP和UDP，下半部分为IP协议控制网络包收发操作，网络包传输过程还使用到 <strong>ICMP协议</strong>（告知网络包传送过程中产生的错误以及各种控制信息）和<strong>ARP协议</strong>（根据 IP 地址查询相应的以太网 MAC 地址）；再往下就是网卡驱动、网卡硬件。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>HTTP 是基于 TCP 协议传输的。</p><p>TCP报头格式：</p><ol><li>源端口号、目的端口号</li><li>序号</li><li>确认序列</li><li>状态位，TCP是面向连接的所以双方要维持连接状态，状态位会引起双方状态的改变；<br><strong>SYN发起连接</strong>、<strong>ACK回复</strong>、<strong>FIN结束连接</strong>、<strong>RST重新连接</strong>；<br><strong>URG紧急标志</strong>，不按序发送，和PSH配合使用；<br><strong>PSH催促标志</strong>，为1时，创建报文立即发送，接收端收到PSH为1的报文就立即将缓冲区数据上交而不是等缓冲区满了才上交；</li><li>窗口大小，声明缓存大小，用于<strong>流量控制</strong></li><li><strong>拥塞控制</strong>，控制发送速度降低拥塞的概率</li><li>数据</li></ol><hr><p><strong>TCP 建立连接的三次握手</strong></p><ol><li>Client和Server都处于关闭状态</li><li>Server主动监听某个端口，处于listen状态</li><li>Client发送SYN，之后处于SYN-SENT状态</li><li>Server返回SYN+ACK，之后处于SYN-RCVD状态</li><li>Client收到SYN+ACK后，发送SYN确认的ACK，然后处于建立连接状态（意味着一发一收成功）</li><li>Server收到来自Client的ACK后，就处于建立连接状态（因为它也一收一发了）</li></ol><p>可见TCP三次握手就是为了<strong>保证双方都有发送和接收的能力</strong>。</p><p>查看TCP连接状态，在终端输入命令<code>netstat -napt</code>。</p><hr><p><strong>TCP数据分割</strong>：</p><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，TCP就需要将数据切割，被拆分数据加上TCP头交给IP模块发送数据。</p><p>所以MSS长度是不包括TCP和IP长度的部分。</p><hr><p><strong>TCP报文生成</strong>：</p><p>源端口就是发送端口；</p><p>目的端口号为Web服务器监听端口，HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>；</p><p>TCP报文中存放HTTP头部+数据；</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>TCP对应的是传输层，解决端对端稳定连接传输问题，那么IP对应的就是网络层，解决怎么传输的问题，通过IP协议将TCP段打包成网络包。</p><p>IP协议中有源地址IP（客户端输出的IP）和目的地址IP（通过DNS解析得到的web服务器IP）。</p><p>IP报头协议号，因为是TCP传输，所以是<code>06</code>。</p><hr><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p><p>根据<strong>路由表规则</strong>判断哪个网卡作为源IP地址。使用<code>route -n</code>命令查看当前路由表。</p><p><strong>默认网关</strong>的 目的IP和子网掩码都是<code>0.0.0.0</code>，如果所有条目都无法匹配就会自动匹配到默认网关，然后打包发给路由器，gateway就是路由地址。</p><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>IP报文生成后，加在TCP段前成为网络包，具有了“远程定位”能力。</p><p>那么如何定位到网络下的设备？</p><p>MAC头部是以太网使用的头部，MAC报头格式包括发送方MAC地址、接收方MAC地址、协议类型（IP<code>0800</code>、ARP<code>0806</code>）；</p><hr><p>MAC地址如何确认？</p><p>发送方的MAC地址记录在网卡ROM，读取到MAC头部即可；</p><p>接收方的MAC地址，局域网下在ARP缓存中找MAC地址，缓存中没找到就是用广播，如果不在同一局域网就使用路由器转发；使用命令<code>arp -a</code>查看缓存；</p><h3 id="网卡、交换机、路由器"><a href="#网卡、交换机、路由器" class="headerlink" title="网卡、交换机、路由器"></a>网卡、交换机、路由器</h3><p>网卡将数字信号转为电信号，控制网卡的是网卡驱动程序。</p><p>网卡获得网络包后会添加帧头（起始帧分界符）、帧尾（FCS），末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏。</p><hr><p>交换机，任务是将网络包<strong>原样</strong>转发到目的地，基于以太网设计，是二层网络设备，端口不具有MAC地址。但交换机有设备MAC地址和端口映射表，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。如果表中没有对应的MAC地址，就采用广播方式，只有相应的接收者会接收网络包。</p><p>如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code>，IP 地址中的 <code>255.255.255.255</code>。</p><hr><p>路由器基于IP设计，是三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；所以它既可以成为以太网的接收方和发送方，也可以连接两个网络。</p><p>工作原理：路由器接收数据包，在路由表中查询转发目标，再以由相应端口作为发送方将以太网包发送出去。接收-将电信号转为数字信号进行校验，端口只接收与MAC地址匹配的数据包，否则丢弃。</p><p>接受网络包后，路由表中找不到对应IP，就会通过默认路由转发出去，默认路由IP <code>0.0.0.0</code>。</p><p><strong>发送操作</strong>：完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部，通过查询路由表找到输出端口，知道对方IP地址就通过ARP查询对方MAC地址，路由器也有ARP缓存。<strong>发送方的MAC地址改为输出端口的MAC</strong>，然后需要完成的任务和计算机一致。</p><p>路由之间转发，最终就会找到目的地址。可以看出，期间源IP和目标IP是不会变（NAT除外），MAC地址会改变，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><hr><p>数据到达服务器后，会从外向内层层“脱掉”前期打包好的头部，得到最后的数据，经过渲染最终让用户看到浏览器上的信息。</p><p>传输完毕后，Client和Server之间会四次挥手，断开连接。</p><h2 id="Linux系统如何收发网络包"><a href="#Linux系统如何收发网络包" class="headerlink" title="Linux系统如何收发网络包"></a>Linux系统如何收发网络包</h2><p>根据TCP&#x2F;IP模型，数据收发都会经过四层，那么放到Linux系统下，具体收发的落实有什么细节？</p><blockquote><p>OSI七层网络模型，过于复杂，只是理论概念上将计算机网络分层，实际应用中还是TCP&#x2F;IP。</p><p>不过，我们常说的七层和四层负载均衡，是用OSI描述的，对应的就是应用层、传输层。</p></blockquote><h3 id="Linux网络协议栈"><a href="#Linux网络协议栈" class="headerlink" title="Linux网络协议栈"></a>Linux网络协议栈</h3><p>TCP&#x2F;IP模型中每个层对应的在数据前增加什么头部要清楚。</p><p>以太网规定的最大传输单元MTU，在1500字节，大于MTU就需要分块传输，MTU除了数据还包括IP和TCP头。MTU越小，分包越多，网络吞吐能力越差；相反，MTU越大，需要分包数量就越少，吞吐能力就越强。</p><p>Linux协议栈就以TCP&#x2F;IP模型为基础。</p><h3 id="Linux接受网络包的流程"><a href="#Linux接受网络包的流程" class="headerlink" title="Linux接受网络包的流程"></a>Linux接受网络包的流程</h3><p>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址（ring buffer，环形缓冲区），然后通知操作系统网络包已到达。</p><p>如何通知操作系统？通常使用<strong>触发中断</strong>，但在高性能网络环境下，频繁中断会影响CPU整体效率。所以采用一种中断和轮询的方式，称为<strong>NAPI机制</strong>，它不采用中断方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p><p>数据包送到后会通过 DMA 技术，将网络包写入到指定的内存地址。接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据<strong>中断表</strong>，调用已经注册的<strong>中断处理函数</strong>。</p><p>中断处理函数解决以下 事情：第一，暂时屏蔽中断，表示已经知道内存已经有数据，下次传输直接写入内存就可以，不需要通知CPU触发中断；第二，发起软中断，然后恢复刚才屏蔽的中断。</p><p><strong>软中断的处理</strong>：内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。ksoftirqd会在buffer中获取一帧数据，用sk_buffer表示，完成后交给<strong>网络协议栈</strong>处理。</p><p><strong>网络协议栈</strong>：网络包先进入网络接口层确认是否合法，否则丢弃，合法网络包去掉帧头帧尾，交给网络层；网络层根据IP判断是交给上层处理还是转发出去，交给本机就查看是TCP还是UDP，交给传输层；传输层根据四元组「<strong>源 IP、源端口、目的 IP、目的端口</strong>」 作为标识，找出对应的 Socket，并把数据放到 <strong>Socket</strong> 的接收缓冲区。</p><p>应用程序就调用socket接口将内核socket接收缓冲区数据拷贝到应用层缓冲区，唤醒用户进程，完成。</p><h3 id="Linux发送网络包的流程"><a href="#Linux发送网络包的流程" class="headerlink" title="Linux发送网络包的流程"></a>Linux发送网络包的流程</h3><p>与接收相反。</p><p>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个<strong>内核态的 sk_buff 内存</strong>，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</p><p>网络协议栈从socket发送缓冲区中取出sk_buff，按照TCP&#x2F;IP协议栈逐步处理。</p><p>传输层，如使用TCP传输，则先拷贝一个<strong>新的 sk_buff 副本</strong>，因为TCP支持丢失重传，所以在收到对方ACK前都会保存副本。</p><p>在sk_buff添加TCP头后交给<strong>网络层</strong>，选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过MTU的数据包进行<strong>分片</strong>，处理完成后交给网络接口层。</p><p><strong>网络接口层</strong>会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</p><p>完成以上工作后，触发软中断，驱动程序读取队列中的sk_buffer，将其挂到环形缓冲区，映射到DMA区域，最后发送。</p><p>完成发送，还没结束，清理sk_buffer和ring_buffer内存，当收到发送的ACK后，传输层释放原始的sk_buffer。</p><blockquote><p><strong>发送网络数据时，涉及几次内存拷贝操作？</strong>三次</p><p>第一次，发送数据的系统调用时，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区；</p><p>第二次，进入TCP传输协议，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，收到ACK后才会释放；</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DJI笔试总结</title>
    <link href="/DJI%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/DJI%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="准备DJI笔试"><a href="#准备DJI笔试" class="headerlink" title="准备DJI笔试"></a>准备DJI笔试</h1><blockquote><p>DJI秋招马上要笔试，按照测开岗位的描述和前人总结，大概率是Python和C，主要是Python。</p><p>这里总结网上搜集的以往笔试题，最新的题是DJI 25秋招笔试，我是最后一批笔试的。</p><p>笔试据说和软开也有重叠的地方，所以也会去关注下。</p></blockquote><h2 id="测评"><a href="#测评" class="headerlink" title="测评"></a>测评</h2><p>DJI 采用的是<strong>海测海笔</strong>。</p><p>笔试前有在线测评，内容基本是行测智力题和性格行为相关的提问，不涉及技术。</p><p>个人觉得没必要专门去练智力题，其实也来不及，而且做测评时间根本不够写完，有几道智力题压根本时间看，就莽猜。</p><p>非要做什么准备的话，那就保证自己做题的时候是精力充沛的就可以了。</p><p>我估计大概就是和笔试一起，作为初筛的参考。</p><p>不过，测评是真的会刷人的，比例不高，这个阶段被刷不需要归因。</p><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>DJI笔试平台是赛码网，据说赛码有些“坑”需要注意下，我平时写题都是在LeetCode（只管写好方法的实现），而且对oi和ACM机制也不太清楚，也不太懂怎么尽可能多ac分数，以下是我搜索整理Python和 C 需要注意的地方。</p><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>赛码网<strong>需要自己处理输入输出</strong>，使用的语言是Python，那么就需要熟悉常用的语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行输入，将输入的数字字符串转为元素为整型的可迭代对象</span><br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, sys.stdin.readline().strip().split())<br>N,M = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()) <span class="hljs-comment"># 直接用input不香吗</span><br><br><span class="hljs-comment"># 多行输入，第一行就说明接下来要输入几行</span><br><span class="hljs-comment"># 第一行采用单行输入的方式，之后的行采用循环方式输入</span><br>matrix = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>tmp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<span class="hljs-comment"># 按照顺序读取矩阵的M行数据，并转换成list</span><br>matrix.append(tmp)<br></code></pre></td></tr></table></figure><p>最后善用strip、split、切片、索引。</p><p>C语言的输入输出也不能落下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x); <span class="hljs-comment">// %f</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the number is %f&quot;</span>, x);<br><br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">puts</span>(str); <span class="hljs-comment">// 结尾自带换行符，gets()结尾是终止符</span><br></code></pre></td></tr></table></figure><p>另外说下C指针，在32位和64位占的字节<strong>分别为4和8字节</strong>，还有要理解<code>*</code>和<code>**</code>的意思。</p><h3 id="赛制"><a href="#赛制" class="headerlink" title="赛制"></a>赛制</h3><blockquote><p>万恶之源，三大赛制：ACM、OI、IOI。</p><p>不刷天梯好多年，一刷一个娘希匹。</p></blockquote><p>ACM：提交有反馈，多个测试点，全部通过才算通过；不限提交次数，最后一次提交为准；通过题数相同的情况下按照答题时间+罚时来排名。</p><p>OI：每道题提交之后都没有任何反馈，每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，如果提交错误没有任何惩罚，仅以最后一次提交为准。按分数排名。</p><p>IOI：每道题提交之后都有反馈，每道题都有多个测试点，根据每道题通过的测试点的数量获得相应的分数。每道题不限制提交次数，按照总得分来排名。（ACM和OI的结合）</p><p>根据能找到的信息，赛码网笔试<strong>可以多次提交，有反馈</strong>。</p><p>笔试以通过为目标，咱也不是竞赛爷，实在想不出来该暴力就暴力（面试不一定）。</p><h2 id="题型-内容范围"><a href="#题型-内容范围" class="headerlink" title="题型&amp;内容范围"></a>题型&amp;内容范围</h2><p>题型：选择（单选、多选）、简答、编程。</p><p>内容范围：Linux、计网、Docker、测试基础、编程（Python、C）、DJI相关的内容。都是基础向</p><p>这些是根据之前笔试的经验贴总结的考点。</p><h3 id="OS-Linux"><a href="#OS-Linux" class="headerlink" title="OS &amp; Linux"></a>OS &amp; Linux</h3><p>Linux具体内容不清楚，可能是Linux理念和常用命令<br>改名使用mv；<br>mkdir命令创建新的目录（其父目录不存在）时的命令；<code>mkdir -p path</code></p><p>OS考察 多线程、堆区、栈区、线程同步方法、编译过程；</p><p>物理内存和虚拟内存的区别和联系；</p><p>进程间通信方式；</p><p>虚拟地址空间为4GB的处理器有几位？32位</p><p>测量系统中最关键的两点性能指标：<strong>吞吐量、延迟</strong>；</p><p>生产者消费者模式；</p><p>栈内存和堆内存的区别；</p><h3 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h3><p>网络分层和常用协议；</p><p>TCP三次握手、四次挥手；</p><p>TCP和UDP；</p><p>ip数据包分片；</p><p>ip层所需解决的问题；</p><h3 id="测试理论基础"><a href="#测试理论基础" class="headerlink" title="测试理论基础"></a>测试理论基础</h3><p>测试测开是什么，测试的目的、测试的几个重点环节；</p><p>单元、集成、系统测试；</p><p>开发阶段测试的正确顺序；</p><p>什么是自动化测试，和手工测试有什么区别；</p><p>黑盒、白盒、灰盒（定义、内容要清楚，讲得出来）；</p><p>给一个功能，怎么设计标准的测试用例；</p><p>无线蓝牙耳机测试用例；</p><p>过往参与的项目的质量保障是怎么做的？如果重新设计一次的话，你会怎么做？<br>过往-测试的基本流程；重新设计-引入自动化测试理念；</p><p>简述测试模型中W模型不同开发和测试阶段对应关系；</p><p>软件测试理论：边界值分析、因果图、组合测试、等价类划分等；</p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>平时写代码多使用C++，所以C语言还是略懂些的，了解下区别就可以了。C 的特点就是接近底层，复习下<strong>指针用法</strong>。</p><p>主要还是Python。</p><p>编程能力没法靠背八股提升，只能练。我找了B站千峰的Python100道笔面题，还搜集了DJI 的笔试编程题，感受下难度。有必要说下，我写题目的方式是视频中<strong>看到题目直接暂停写题，不懂直接搜索</strong>，基本上不听讲师。题目都整理到 <strong>Python100</strong> 的文章里了。</p><p>编程考察两个方向，<strong>语法和算法</strong>。语法之前跟着廖雪峰的博客学完了基础，算法嘛也就会基本的数据结构和简单<strong>排序、查找</strong>算法。为了后续面试，DSA还是不能放。以下是目前需要准备的：</p><ol><li>排序算法，<strong>冒泡、选择、快排</strong>；真来不及总得知道原理吧</li><li>二分法查找，二分链表法</li><li>斐波那契</li><li>爬楼梯、找零钱</li><li>多线程、多进程</li><li>Python常用方法</li><li>高阶函数、lamda、装饰器、生成器</li><li>C基本语法，常用函数<ol><li>32bit系统中sizeof(指针数组)的大小</li></ol></li><li>正则表达式</li><li>数据结构基础知识<ol><li>在存储上可以分为顺序、链式、散列、索引</li></ol></li></ol><blockquote><p>Python给我一种<strong>非常灵活导致难以掌握</strong>的感觉，灵活在于变量的类型不需要程序员给定，还有就是缩进、分号和各种语法糖，所以在编写代码的时候<strong>Python给出的代码可能比我想象得更直接更简洁一些</strong>。使用起来没有C++和Java那种实在的感觉，不过也没办法，只能通过练习掌握这些细节。</p></blockquote><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>面试官：数据库…MySQL…Redis…？</p><p>我：妈妈生的。</p></blockquote><ol><li>DELETE和TRUNCATE：如果需要删除表中的所有记录，并且对性能有较高要求，可以使用TRUNCATE。如果需要根据特定条件删除记录，或者需要保留删除操作的日志以支持事务回滚，应该使用DELETE。</li><li>MySQL基本操作，增删改查</li><li>ORM（这个是我猜的，应该不会在笔试考到吧，我靠）</li></ol><h2 id="笔试之后"><a href="#笔试之后" class="headerlink" title="笔试之后"></a>笔试之后</h2><p>这里是8月18号笔试后的总结。</p><p>题量：14道单选、12道多选、2道解答、1道代码；</p><p>范围大部分确实是预计的那样。总体看简单。</p><h3 id="猜中的地方"><a href="#猜中的地方" class="headerlink" title="猜中的地方"></a>猜中的地方</h3><ol><li>Linux指令，有学习find查找，但是并不清楚maxdepth的默认深度是多少；<br>多选，错了个选项；</li><li>TCP三次握手以及理由；<br>简答题，TCP是什么、目的、三次握手的流程我写了遍，但对更底层的方法其实还是不清楚，后续还需深入学习；</li><li>测试用例，测试一个API的输入输出，输入不均匀时间戳和可能为None的海拔，输出均匀的时间戳和插值后的海拔高度。用例3-5个；<br>其实我也不清楚用例设计有啥讲究，就是要细，利用黑盒测试的方法设计用例。</li><li>测试基础知识，这个太宽了，很多文字类工作，例如描述正在做什么事，指出这是测试的哪个流程；简单的也有，白盒测试特点，黑盒测试包括哪些方法等</li></ol><h3 id="比较细节的地方"><a href="#比较细节的地方" class="headerlink" title="比较细节的地方"></a>比较细节的地方</h3><ol><li>C语言 printf中占位符 <code>%o %x</code>，<code>%#o %#x</code>，既考察了数制，又考察了占位符输出的差别，仅一个#差别，输出会加上进制的前缀；<br>写错了，没拿分，太细了呜呜呜</li><li>正则表达式，匹配字符串。细到选项里纠结<code>?!str</code>是包括str还是不包括，没正经学过正则，想到平时写代码！是取反的意思，也就直接选不包括了；<br>后来查了下，写对了</li><li>cv2库中blur和高斯模糊的区别；考到OpenCV是我没想到的；<br>不确定 ，这种算子，我都是用到再去搜，时间久了就忘</li><li>C++虚函数，纯虚函数（当时在想和Java的接口是不是一个意思）；<br>大一学的，没怎么用过，忘得很干净</li><li>测试工具，pytest和JMeter的使用比较；没深入啊，瞎选了</li></ol><h3 id="奇葩的地方"><a href="#奇葩的地方" class="headerlink" title="奇葩的地方"></a>奇葩的地方</h3><p>我必须要吐槽下代码题，既吐槽平台，也吐槽自己。</p><p>代码在本地VScode上可以通过，<strong>在赛码网上不行</strong>（最担心的事情还是发生了）。</p><p>但更坑的是，样例没通过，我竟然<strong>没有仔细看平台的报错信息</strong>。吃了大亏了呜呜呜。</p><p>代码题语言是Python，难度easy，实现一个文件名字符串列表的分割重新存放到新列表的方法，甚至没考装饰器那些东西，所以才觉得亏。</p><p>笔试前熟悉平台，遇到报错不要慌，看清楚报错信息，可能压根不是代码的问题，而是平台测试代码需要设置不一样的IO 罢了。</p><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>DJI 的测评、笔试都是作为筛简历的参考，筛简历看重岗位契合度。到了面试，长时间的拷打下基本不可能有水分。</p><ol><li>Linux：多使用，一些常用指令的选项还是需要熟悉的；Linux的设计理念、核心参数要看懂，要知道怎么看；</li><li>正则表达式：花点时间理理，顺便进阶下vim、Shell脚本；</li><li>C&#x2F;C++：语法虽然考的细，但其实平时用的时候有注意到，用排除法还是正确回答的；</li><li>测试工具：自动化测试框架，还需熟悉；</li><li>测试理论：有了基本的框架，但还不够；</li><li>OS、计网、MySQL、Redis：八股、常考面试题、面经</li><li>Python：在过一遍Python100题、面经、廖雪峰</li><li>准备面试，拷打简历<ol><li>面试经验——面经、试试非目标企业面试、《剑指offer》；</li><li>个人经历，非技术；</li><li>比赛中的困难，技术&amp;非技术；</li><li>视觉项目相关，再看看自己shitcode理出技术路线，对比下参考的开源项目，把一些技术细节整理好，项目中使用的OpenCV方法需要熟悉，软硬件解决的问题整理好；（可以再看看视觉圣经）</li><li>自制OS项目相关，基础向-OS组成、常用操作系统、和硬件的适配，难点及问题解决，收获；参考下以此为项目的面经（看看人家是怎么被拷打的）；</li><li>八股：小林coding、代码随想录、JavaGuide、阿秀，知名专业书籍；</li><li>Docker、k8s、CICD、Git；</li><li>未来发展，如实回答就好；</li><li>行业认知，如实回答就好；</li><li>反问，企业-岗位-专业</li></ol></li></ol><hr><p><strong>我的劣势</strong>：第一，八股文看的太晚了；第二，两个简历项目要么范围很广可能会导致面试时解释技术点不集中，要么做的比较早，一些技术点已经遗忘。综上，我的学习曲线那是相当陡峭了，没办法，只能肝！</p><p>其实不管DJI 给不给面试，要做的还是两点，一是<strong>扎实计算机和测试的基础</strong>，二是<strong>回顾补齐简历上的技术栈</strong>。针对面试的准备，大概就是阅读测开面经，预先准备一些非技术的话题答复。</p><p>我关注很多来自各个平台的博主，他们发的笔面大多是算法、开发，难度都大于测开，所以代码能力自觉欠缺的同学可以考虑下这个职业。这个欠缺还是相对与优秀的欠缺。。。</p><p>选择测开，倒不是代码能力的原因，主要还是想先找个岗位切入到行业里。我对开发和算法岗、对进互联网企业没有啥执念，大疆的测开岗位推荐里吸引我的一点就是可以参与产品全流程的研发。</p><p>工作以后还是要抱着<strong>带薪学习</strong>的心态，有些东西学的差不多了，情况合适的话就继续往机器人方向继续发展，学习前沿的研究成果，参与一些知名开源，继续提升自己的能力。说来惭愧，知乎YY硕的机器人学习篇，我大学三年了还没学到一半。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网-体系（一）</title>
    <link href="/%E8%AE%A1%E7%BD%91-%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/%E8%AE%A1%E7%BD%91-%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="计网-体系（一）"><a href="#计网-体系（一）" class="headerlink" title="计网-体系（一）"></a>计网-体系（一）</h1><blockquote><p>马上笔试了，测开岗位笔试内容大概就是Linux、计网、Docker、测试理论基础。</p><p>肯定还是要靠突击的。</p><p>平时上课学的那些东西先不说剩多少，当时就没怎么学，水成什么样了，nnd！</p><p>重新听课看视频肯定是来不及的，所以直接拿起八股就是干！</p><p>参考小林coding和代码随想录的八股PDF，建议直接去看这些材料，都是可以搜到的。</p></blockquote><h2 id="fei话"><a href="#fei话" class="headerlink" title="fei话"></a>fei话</h2><p>先说下，我学计算机到目前为止认为的最重要的两个思想，<strong>一个是抽象，一个是复用</strong>。</p><p>计算机网络、操作系统就是将复杂底层逐步往高可用抽象的结果；复用追求的是节约生命，站在前人的肩膀上解决问题，当然作为合格程序员还是要知其所以然的，但作为懒狗的我，知道原理后是不可能再去重复造轮子的，除非我有比轮子更牛逼的想法。</p><p>以上是目前我认为学习计算机<strong>需要具备</strong>的两个思想（其实是很多人都这么认为的，就是这么回事）。</p><hr><p>菜不菜，其实自己心里最清楚。</p><p>网络给我的印象就是它无处不在但我又对它概念模糊，路由器和WiFi盒子有啥区别？为啥VPN可以翻？网络攻击是啥东西？网络设备信息有啥东西是不可以泄露的？啥是渗透，kali咋用，和网络有啥关系？</p><p><strong>鼠鼠我啊，一点都不知道呢</strong>。所以当我跟别人说网段、端口之类的（简单）概念时，总以为我网络知识扎实，其实我内心是很难绷的；当别人知道我学计算机，问我能不能黑别人电脑时，就更难绷了艹。</p><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p>教科书上的是OSI七层模型，先不看那玩意儿。</p><p>常用的是<strong>TCP&#x2F;IP网络模型</strong>，模型就是分层，学习计网就是要讲清楚从底层到应用层发生了啥。</p><p>同一设备进程间通信可以使用管道、消息队列、共享内存、信号等方式；</p><p>不同设备上的进程通信就需要一个通用协议，而这个协议是分层的。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>不用去关心数据是如何传输的，专注于用户提供应用功能，例如HTTP、FTP、DNS、Telnet、SMTP等。怎么传输交给传输层。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><blockquote><p>面试题：阐述TCP和UDP的区别。</p></blockquote><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP，传输控制协议，可靠性高，所以它肯定是有很多UDP没有的特性；大部分应用使用，比如 HTTP 应用层协议。</p><p>UDP，用户数据报协议，不可靠、实时性高，没有建立连接的过程（<strong>这是什么意思</strong>？）。使用对可靠性要求不高的场景，例如视频会议、实时游戏等。</p><p>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要<strong>将数据包分块</strong>，每个分块成为TCP段。传输出现丢失，只需要补齐缺失的TCP段即可。</p><p>传输数据如何找到设备上对应的应用（进程）？<strong>根据端口</strong>。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>传输层负责在两个主机的<strong>应用程序之间</strong>提供通信服务。所以传输层更关注于端到端的通信质量，确保数据的完整性和可靠性，而网络层则关注于数据在网络中的<strong>传输路径和基本的数据传输功能</strong>。</p></blockquote><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>为了让传输层简单、高效、专注，传输层<strong>不负责将数据从一个设备传输到另一个设备</strong>。</p><p>那传输层负责什么来着？见传输层段落的结尾。</p><p>网络层最常使用的是 IP 协议。传输层报文作为数据部分，加上IP组成IP报文，大小超过最大传输单元（MTU），就会分片得到IP报文。</p><p>网络层就是找设备环节，设备标识在网络层就是IP地址。对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段8位。寻址<strong>根据网络号和设备号（主机号）</strong>，网络号标识子网，主机号标识同一子网下的不同主机。</p><p>IP地址还需要通过子网掩码才能算出网络号和主机号。</p><blockquote><p> 例如，10.100.122.0&#x2F;24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，对应的二进制就是「11111111-11111111-11111111-00000000」，24个1，所以简化为 &#x2F;24</p><p>将IP地址和子网掩码进行<strong>按位与</strong>运算，得到<strong>网络号</strong></p><p>将子网掩码取反后，和IP地址按位与运算，得到主机号</p></blockquote><p>IP协议除了寻址，<strong>另一个重要能力是路由</strong>。当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。所以寻址给出大致方向和目标，路由则是负责具体的传输路径。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>这层其实&lt;计网初步篇&gt;中提到的数据链路层，在以太网进行通讯要用到 MAC 地址，所以我觉得称为MAC层也挺合适。</p><p>因为IP走到这一层，需要寻找设备，设备的标识是啥呢？<strong>MAC地址</strong>。</p><p>MAC头部是以太网使用的头部，包含了<strong>接收方和发送方的 MAC 地址</strong>等信息，我们可以通过 <strong>ARP 协议</strong>获取对方的 MAC 地址。</p><p>那啥是以太网？它是在<strong>局域网内</strong>把设备连接起来的网络，组成部分包括电脑以太网接口、WiFi接口、以太网交换机等，在以太网进行通讯要用到 MAC 地址。</p><blockquote><p>TCP&#x2F;IP模型就四层，按理说最底层是物理层，所以可以看出这个模型是软件模型，不涉及硬件细节。</p><p>另外，四个层次，从上到下每经过一层将数据进行<strong>封装的格式</strong>要清楚，TCP头-IP头-MAC头；传输单位，在应用层是消息或报文，在传输层是段，在网络层是包，在接口层是帧，但都可以统称为数据包。</p></blockquote><p>第一篇就写这么多，第二篇将会通过一道面试题构建网络拓扑模型，冲冲冲！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网-初步</title>
    <link href="/%E8%AE%A1%E7%BD%91-%E5%88%9D%E6%AD%A5/"/>
    <url>/%E8%AE%A1%E7%BD%91-%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="计网-初步"><a href="#计网-初步" class="headerlink" title="计网-初步"></a>计网-初步</h1><blockquote><p>看到一个通俗易懂的B站科普教程，up主是free-coder</p><p>本篇就总结这一视频作为计网学习的第一步</p></blockquote><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>两台主机要通信，最直接的办法就是连接一根能够传输电信号的线。</p><p>按照这条件，多台主机就是多条线，每台之间都要通信就要全连接。</p><p>哪来那么多线啊？得想办法降低成本。</p><p>所以就有了集线器（Hub），逻辑上就记住两点，一个是<strong>标识</strong>，一个是<strong>转发</strong>。</p><p>集线器可以视为带标识的广播。但依旧存在两个问题：</p><ol><li>既然是广播，怎么判断信号要发给谁？标识</li><li>传输通道上同时出现多个信号，怎么解决？CSMA&#x2F;CD协议</li></ol><p>CSMA&#x2F;CD协议，监听线路状态，空闲发送否则等待。</p><hr><p>使用集线器的缺点：功能简单、带宽利用率低、终端越多冲突可能性就增加</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>弥补集线器的缺陷，引入交换机。</p><p>交换机有一张表用于记录地址，记录MAC地址和端口。</p><p>MAC地址又称为<strong>物理地址</strong>，有48bit，分6个字段，每个字段8位。</p><p>交换机是全双工（同时收发），使用网线连接。</p><p>交换机的表原先是空表，通过广播找到对应的端口映射关系。</p><p>交换机可以进行桥接，也就是多台交换机可以连接在一起，所以另一台交换机上的设备在当前交换机的映射都是对应同一端口。</p><hr><p>交换机表的存储量还是太少，不能够支撑器全球范围的设备通信，只适用于局域网。</p><p>另一个缺陷是如果设备过多则寻址时间会非常长。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>跨局域网的互通，也就是互联网。</p><p>网络和网络的连接，需要使用<strong>路由器，又称为网关</strong>，处于两个网络之间的连接点。</p><p>如何表示跨局域网络的标识？IP地址。</p><p>IP是一个抽象地址，用来<strong>标识网络和设备</strong>。</p><p>每一个设备都有自己的路由表。而路由器的路由表就有两个网络的IP。</p><p>路由表的建立比前文提到的MAC地址映射要复杂多，其算法仍在更新。</p><p>网络内传输数据依旧是通过MAC地址，不是直接使用IP地址，<strong>IP不能直接用作通信</strong>，由此可知，MAC地址才是真实的地址。所以本地查找另一个设备的IP使用<strong>ARP协议</strong>，<strong>使用广播寻找IP对应的物理地址</strong>。找到后就在MAC层（数据链路层）进行传输。</p><p>跨网络与另一网络的设备通信。还是先在网络内找到路由器IP对应的MAC地址，以此类推。在寻址时，IP一般不会切换，主要通过ARP协议寻找MAC地址，NAT特殊（IP也会切换）。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>针对前面三个层搭建了简单的认知后，再往上就是传输层、应用层，就是TCP、UDP、HTTP之类的。</p><p>最后提几个问题，抛砖引玉，接下来就是通过系统学习回答一下问题。</p><blockquote><p>路由器上的WAN口、LAN口分别是什么？有几个实体网卡，一个网口对应一个网卡吗？</p><p>路由器有多少个IP？</p><p>电脑、手机连接路由时并没有设置IP，那么IP是怎么获得的？</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试理论基础（一）</title>
    <link href="/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="测试理论基础（一）"><a href="#测试理论基础（一）" class="headerlink" title="测试理论基础（一）"></a>测试理论基础（一）</h1><blockquote><p>5月份中部区域赛结束，还是个测试小白，测不了一点。</p><p>这系列是综合各种技术文档和公众号总结出来的，目的就是搭建测试理论体系。</p><p>学完理论基础再去牛客刷题（专项练习-测试）。</p></blockquote><h2 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h2><p>测试是什么？</p><p>软件开发中难免会有Bug，测试的作用就是及时找到程序存在的Bug和缺陷。</p><ol><li><strong>测试软件是否满足的用户提出的需求</strong>。这种情况下，我们应当对<strong>需求文档中的每一个需求都要编写测试样例进行测试</strong>，观察在合法输入下我们的软件是否能给出期望的输出。</li><li>测试软件<strong>是否存在缺陷</strong>，找出可能导致软件行为异常甚至崩溃的输入序列，避免这种情况的发生。</li></ol><p>总结就是<strong>测需求、测缺陷</strong>。测需求就是选用合法输入以验证是否给出正确输出，测缺陷就是通过非法输入验证程序鲁棒性。两者都可以测出软件存在的缺陷和Bug。需要注意，即使通过了测试，程序也可能存在Bug。</p><p>软件测试分为开发测试、发布测试、用户测试。主要关注开发测试，在开发过程中发现Bug和缺陷，开发测试分为：</p><ol><li>单元测试，对程序的<strong>各个单元</strong>进行测试。程序的<strong>单元可能是函数、方法、类对象</strong>，等等；</li><li>构件测试，对多个不同的单元、构件进行集成以<strong>创建一个复合构件</strong>，专注于不同构件的接口之间的关系； </li><li>系统测试：整个系统进行测试</li></ol><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>测试理论大概有什么？</p><ol><li>测试流程：瀑布模型，双v模型，螺旋模型等</li><li>测试手段：黑盒测试，灰盒测试，白盒测试，静态测试，动态测试</li><li>测试阶段：测试过程中对应的阶段</li><li>测试成果</li><li>测试点方法：功能、非功能（iso9126）、接口（软、硬、用户接口）</li><li>黑盒测试用例设计</li><li>白盒测试用例设计</li><li>灰盒用例设计</li><li>质量铁三角</li><li>cmm5级质量图</li><li>用例标准属性</li><li>Bug等级</li><li>iso9126</li></ol><h2 id="输入处理和输出"><a href="#输入处理和输出" class="headerlink" title="输入处理和输出"></a>输入处理和输出</h2><h3 id="更新一个观点"><a href="#更新一个观点" class="headerlink" title="更新一个观点"></a>更新一个观点</h3><p>弄清楚一个问题：测试理论和流程不是线性的，而是网状结构。</p><p>测试阶段分为：单元测试-集成测试-系统测试。这句理论和<strong>功非接不是一条线串联</strong>的，而是融合的。例如，集成测试包含功能和非功能的测试点，功能又包含单元-集成-系统测试。</p><p>乍一看很复杂，但目前只需要知道，</p><p><strong>功能 &#x3D; 多个阶段 ✖️（输入+处理+输出）</strong></p><h3 id="输入-处理-输出"><a href="#输入-处理-输出" class="headerlink" title="输入-处理-输出"></a>输入-处理-输出</h3><p>任何功能的实现的三个过程。这三个过程，都要进行测试。</p><p>以<strong>登录功能</strong>为例，可以分：</p><ol><li>输入：登录名、密码、验证码</li><li>处理：服务器、中间件等</li><li>输出：成功则页面跳转，失败则出现提示</li></ol><p>以上的测试内容还不全面，三个过程还可以细分为<strong>可见&#x2F;不可见</strong>。</p><ol><li>输入<br>无论是可见还是不可见，要通过测试确保，这些参数字段成功的生成了请求体，组成了正确的接口请求。<ol><li>可见：输入的用户名，密码，验证码，是否勾选协议，登录按钮等</li><li>不可见：登录日期、IP、安全环境检测、物理设备号、缓存等</li></ol></li><li>处理<ol><li>可见：代码、函数等，可用白盒测试</li><li>不可见：外链引用、库、第三方服务等</li></ol></li><li>输出<ol><li>可见：前文的界面反馈</li><li>不可见：接口返回参数-错误码、缓存、客户端的本地配置等</li></ol></li></ol><h2 id="非功能"><a href="#非功能" class="headerlink" title="非功能"></a>非功能</h2><p>非功能有六大特性。。。</p><h3 id="功能性测试"><a href="#功能性测试" class="headerlink" title="功能性测试"></a>功能性测试</h3><blockquote><p>思考：非功能的功能性和功能测试有什么区别？</p></blockquote><p>非功能的功能性的五个特性：</p><ol><li>适合性，侧重于用户需求的适合性，提供了需要的功能，提供的功能是用户需要的</li><li>准确性，提供给用户功能的准确度（其实还是和需求挂钩）</li><li>互操作性，软件和其他系统交互的能力，例如PC中打印机和word的接口调用</li><li>保密安全性，权限、隐私</li><li>依从性，顺应法律和用户使用习惯（各种标准）</li></ol><h3 id="可靠性测试"><a href="#可靠性测试" class="headerlink" title="可靠性测试"></a>可靠性测试</h3><ol><li>成熟性，避免软件Bug导致系统失效的能力，例如，Bug导致用户信息丢失。</li><li>容错性，避免外部接口错误扩散导致系统失效，例如，打印机中途断电不会导致word运行</li><li>易恢复性，故障后可以恢复原有功能和性能</li><li>依从性，保证可靠性的业内规则，例如安全备份</li></ol><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ol><li>易理解性，给用户的信息要清晰易懂，反例就是看不懂怎么用</li><li>易学性，用户可以学习应用的能力，用户手册的语言中英文、是否齐全、是否有在线人工服务</li><li>易操作性，易操作和控制上的能力，安装步骤是否简单</li><li>吸引性，吸引用户的能力、界面外观</li><li>依从性，遵循设计标准</li></ol><h3 id="效率性"><a href="#效率性" class="headerlink" title="效率性"></a>效率性</h3><p>和性能测试，压力测试，负载测试有重合的地方。或者说压力测试属于效率性的一部分。</p><ol><li>时间特性，也就是<strong>性能测试</strong>，业务请求所需要的响应时间。不单是接口压测，还要全面分层衡量，如客户端渲染的速度，缓存文件读写的速度，接口请求的速度，数据库读写的速度等等。</li><li>资源利用性，业务请求所消耗的系统资源。内存、硬盘、流量、电能</li><li>依从性，不能比同行差太多吧</li></ol><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ol><li>适应性，无需变动就能适应环境的能力</li><li>易安装性，尽可能少的提供选择，方便用户直接安装</li><li>共存性，在公共环境中与其它软件分享公共资源共存的软件，不冲突</li><li>易替换性，做好兼容适配，例如早期鸿蒙兼容安卓</li><li>依从性，依据规范、法律做可移植</li></ol><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>与shi山的斗争。</p><ol><li>易分析性，提供辅助手段帮助开发人员定位缺陷产生的原因，判断出修改的地方</li><li>易改变性，高内聚低耦合</li><li>易测试性，日志输出，方便测试</li><li>依从性，开发代码符合规范，变量名、注释文档</li></ol><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><blockquote><p>什么是Bug？怎么跟踪？怎么Bug分级？</p></blockquote><h3 id="Bug属性"><a href="#Bug属性" class="headerlink" title="Bug属性"></a>Bug属性</h3><p>提交Bug会使用一些Bug管理工具，但什么标准，以下是Bug标准属性：</p><p>需求id，用例id，bug编号，bug标题，bug描述，预期输出，实际输出，复现步骤，附件图片，备注，提交人，责任人 等</p><h3 id="Bug分级"><a href="#Bug分级" class="headerlink" title="Bug分级"></a>Bug分级</h3><p>致命——严重——一般——轻微——优化</p><ol><li>致命，引起系统服务崩溃，用户关键数据丢失，巨大资产损失，生命安全风险</li><li>严重，引起软件主要功能失效</li><li>一般，主要功能失准，次要功能失效</li><li>轻微，次要功能失准</li><li>优化，影响用户体验，文案错别字等</li></ol><h3 id="Bug生命周期"><a href="#Bug生命周期" class="headerlink" title="Bug生命周期"></a>Bug生命周期</h3><p>这个过程中有几个重要角色：</p><ol><li>测试工程师，提交Bug、验证修改后的Bug</li><li>测试经理，判断是否是Bug，确定Bug是否重复</li><li>开发经理，是否延期修复</li><li>CCB，变更控制委员会，开发拒绝修复则提交CCB（类似仲裁）</li><li>开发工程师，改bug</li></ol><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><blockquote><p>如果面试中提到测试流程，双v模型最终阶段-验收测试，面试官一问验收测试流程是什么？</p><p>可能就懵了。</p><p>为了避免成为书呆子，就有必要知道每个概念后的含义。</p></blockquote><ol><li>验收测试项目洽谈，签好合同。（测试一般不参与的）</li><li>提交测试样品，改到满意为止</li><li>编写测试计划并通过评审（需要测试参与沟通）</li><li>简单培训，进行测试设计，编制测试方案</li><li>方案通过后，开始测试，编写测试报告</li></ol><p>这个环节着实是没太多营养。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><blockquote><p>Linux的历史发展可以自行了解。</p><p>UNIX系统发展可以阅读《UNIX传奇》</p></blockquote><p>逛B站，偶然翻到清华科协暑培的Linux课程，非常适合作为入门上手的资料，文档链接如下：</p><p><a href="https://docs.eesast.com/docs/tools/linux&shell">Linux &amp; Shell | EESΛST Docs (eesast.com)</a></p><blockquote><p>本篇不是将文档复述一遍，而是在此基础上的强调和补充。</p></blockquote><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ol><li>输入<code>whoami</code>，查看当前身份</li><li><code>cat /etc/passwd</code>，查看全部用户属性</li><li><code>cat /etc/group</code>，查看用户组</li><li><code>sudo usermod -aG [groupname] [username]</code>，添加指定用户到指定组</li><li><code>newgrp [groupname]</code>切换用户组</li><li>查看文件，除了<code>ls</code>，还有<code>ll</code>相当于<code>ls -al</code>；了解文件权限意思</li><li>修改权限，<code>chmod</code>，读r权重为4，写w权重为2，执行x权重为1</li><li>通过 chown 命令来修改文件的属主和属组，需要使用超级用户权限修改</li></ol><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>Linux的设计哲学是一切皆文件，其文件结构呈树状。</p><ol><li>&#x2F;boot是内核文件，包括镜像文件和连接文件</li><li>&#x2F;etc存放所有的系统需要的配置文件和子目录列表</li><li>&#x2F;lib存放共享库</li><li>**&#x2F;bin 存放常用程序和指令</li><li>**&#x2F;sbin 只有系统管理员能使用的程序和指令</li><li>外部设备，&#x2F;dev 外部设备，&#x2F;media 类win的其他设备，&#x2F;mnt临时挂载别的文件系统</li><li>临时文件，&#x2F;run、&#x2F;tmp</li><li>账户文件，常见的有root和home，&#x2F;usr是存放应用程序和文件的目录，类似Windows的program files</li></ol><p>磁盘管理，在win上可以使用文件资源管理和磁盘管理实现分区管理。在Linux上：</p><ol><li><code>df -h /home</code>，查看分区磁盘使用情况</li><li><code>du -h demo</code>，查看demo文件的存储占用情况</li><li>fdisk用于操作磁盘分区表</li><li>mkfs用于格式化指定磁盘</li><li>将某个文件系统挂载到目录下，使用mount，取消挂载使用unmount</li></ol><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h3><p>前文已经涉及到Shell命令，命令中涉及的参数如果记不住可以使用man命令</p><p><code>man [command name]</code>，除此之外，还有实用的命令：</p><ol><li><code>tree demo</code>，展示demo目录的文件结构</li><li>find用于查找文件，whereis可以查找二进制文件、源代码、man手册</li><li>创建目录，<code>mkdir</code>，创建文件<code>touch</code></li><li>复制和移动文件或目录，<code>cp</code>、<code>mv</code></li></ol><p>系统管理命令：CPU、内存管理情况</p><ol><li><code>top</code>，查看内存情况</li><li><code>ps aux</code>，查看进程，aux分别是三个选项；kill可以终止进程，但无法终止系统和守护进程</li><li><code>apt</code>，包管理工具。update列出所有可升级的软件，upgrade升级所有软件包，remove删除软件包，autoremove清理不再使用的依赖库，search查找包；除了apt，还有<code>snap</code>软件管理</li><li><code>cat</code>打印文件内容；<code>grep</code>查找与给定正则表达式匹配的内容</li></ol><p>vim编辑器，了解常用的指令，也可以通过配置插件作为开发工具。</p><p>输入输出重定向，<code>&gt;</code>和<code>&gt;&gt;</code></p><ol><li>命令 &gt; 文件，将命令结果重定向输出到指定文件，会覆盖</li><li>命令 2&gt; 文件，将命令执行的错误重定向输出到指定文件，会覆盖</li><li><code>&gt;&gt;</code>，不会覆盖文件已有数据</li></ol><p>管道pipe<code>|</code>，将一个命令作为下一个命令的输入，例如<code>ls | grep demo</code>用于搜索文件名包含demo的文件，ls的输出作为grep的输入。</p><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>Shell脚本是在Shell中运行的程序，用于完成一些自动化任务和。</p><ol><li><p>注释</p></li><li><p>变量，<code>a=1</code>，注意不要空格，查看变量<code>echo $a</code>；删除变量<code>unset a</code></p></li><li><p>数组，<code>array=(1 2 3)</code>，注意不需要空格和逗号分隔；<code>echo $&#123;array[@]&#125;</code>，@表示数组中所有元素</p></li><li><p>分支&amp;循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">分支</span><br>if condition1<br>then<br>command1<br>elif condition2<br>then<br>command2<br>else<br>command3<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环</span><br>for file in file1.txt file2.txt file3.txt<br>do<br>    cat &quot;$file&quot;<br>done<br><br>a=0<br>while [ $a -le 10 ]<br>do<br>command # 注意内部使用变量要加$符号<br>done<br></code></pre></td></tr></table></figure></li><li><p>函数，<code>function test()&#123; command; return $result &#125;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">function test()&#123;<br>    echo &quot;参数1： $&#123;1&#125; !&quot;;             # 通过$&#123;n&#125;来获取传入函数的第n个参数<br>    echo &quot;参数10： $&#123;10&#125; !&quot;;    # 双引号括起来的字符串中可以引用变量<br>    n=$(($&#123;1&#125;+$&#123;10&#125;));<br>    return $n;     # 如果不加return，则返回值为最后一条命令的结果<br>&#125;<br><br>test 1 2 3 4 5 6 7 8 9 10;            # 调用函数时依序传递参数<br>echo $?;                              # 可以通过变量$?来获取函数的返回值或者上一条命令的结果<br></code></pre></td></tr></table></figure></li><li><p>运行方式，<code>./demo.sh</code>和<code>bash demo.sh</code></p></li></ol><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量是存放Shell工作环境的数据，以便访问。</p><p>查看环境变量，全局<code>env</code>，HOME变量<code>echo $HOME</code></p><p>设置环境变量，分临时和永久设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">临时设置</span><br>variable=&quot;test&quot;<br>export variable# 导出环境变量<br>unset variable# 删除环境变量<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如想设置持久的环境变量，就需要修改系统启动时用于加载环境变量的文件</span><br>/etc/profile# 系统级，登录shell当中加载<br>/etc/bashrc# 系统级，可认为都会被加载<br>~/.profile# 用户级，登录shell当中加载<br>~/.bashrc# 用户级，可认为都会被加载<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 PATH 环境变量时，一般采用追加导出的方式，即在文件的最后一行加上</span><br>export PATH=/usr/local/src/mongodb/bin:$PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量立即生效，可以使用<span class="hljs-built_in">source</span></span><br>source [file name]<br></code></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>全称是Secure Shell，安全外壳协议。为远程登录会话提供安全协议：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh user@hostname  # 主机名可以是IP地址或者域名<br>ssh -p [port] user@hostname   # SSH默认连接到目标主机的22端口，可以通过-p指定其他端口<br></code></pre></td></tr></table></figure><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>当远程断开后，服务器正运行的会话终止。 tmux 是用来解绑会话与打开的终端窗口的，可以让你启动的进程在断开连接之后继续运行。</p><ol><li><code>tmux new -s &lt;session name&gt;</code>，新建tmux会话</li><li>在 tmux 窗口中，按下<code>Ctrl+b</code>，然后按<code>d</code>，d是detach的意思。返回原先Shell但tmux窗口仍在后台运行；可以用<code>tmux attach -t &lt;session name&gt;</code>接回。</li><li><code>tmux kill-session -t &lt;session name&gt;</code>，关闭会话</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>最后附上两题的答案，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">第一题，求 100 以内的奇数和。结果打印到标准输出设备。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>sum=0<br>for i in &#123;1..100..2&#125;<br>do<br>  let sum=$((sum + i))<br>done<br>echo &quot;The sum of odd numbers from 1 to 99 is: $sum&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第二题，在家目录下新建 data 目录并向其中新建 100 个名为 test1.txt,…,test100.txt 的文件。之后查找到 data 目录下所有文件名包含“5”的文件，并向其中分别写入文件名中的数字这么多行的“abcd”。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建 data 目录</span><br>mkdir -p ~/data<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环创建 100 个文件</span><br>for i in &#123;1..100&#125;<br>do<br>    touch ~/data/test$i.txt<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环查找所有文件名包含<span class="hljs-string">&quot;5&quot;</span>的文件，并写入相应数量的<span class="hljs-string">&quot;abcd&quot;</span></span><br>for file in ~/data/test[5-9]*.txt<br>do<br>    # 使用文件名中的数字作为循环次数<br>    num=$(basename &quot;$file&quot; | grep -o &#x27;[0-9]\+&#x27;)<br>    for (( j=1; j&lt;=num; j++ ))<br>    do<br>        echo &quot;abcd&quot; &gt;&gt; &quot;$file&quot;<br>    done<br>done<br><br>echo &quot;操作完成。&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开篇</title>
    <link href="/%E5%BC%80%E7%AF%87/"/>
    <url>/%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><h2 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h2><p>​博客是写给自己看的，文笔上没太多讲究。先使用Hexo和Github搭建（免费），有更多需求后再考虑部署到云服务上。</p><p>​三年计算机专业学习，两年的RoboMaster经历，积累了不少笔记，都零零散散“堆积”在我的文件夹里。正处于应届秋招开始的档口，整理技术文档是非常有必要的。所以，技术博客的推送时间并不代表写文章的时间，主要按照主题、标题和Tag来整理成专题。</p><p>目前计划要写的方向：</p><ol><li>学习笔记记录，主要是计算机核心课程</li><li>项目开发过程记录，例如 MIT6.S081、RPC、CMU15-445、南大ICS的PA</li><li>开源项目的源码分析，例如 Transformer、PyTorch、YOLO</li><li>偶尔会整理有趣的算法题解析</li><li>RoboMaster的内容会整理到战队博客上</li><li>其他——经验、方法及感想</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
